#变量

- 类型：int  float   char  list  tuple  dict   set
> 整数  浮点数  字符  列表   元组   字典    集合
    ##命名：
- 大驼峰：
>单词首字母全部大写  (__class类的要求写法！__)
			MyName，YouOne
- 小驼峰：
>第一个单词首字母小写，其余大写
			myName，youOne
- posix规则写法：
>以下划线_区分单词   （__普通变量写法__）
			my_name，you_one

************************************************************
#Number数字进制

- 二进制：0b开头  0b10011
- 八进制：0o开头  包含0-7
- 十六进制：0x开头 
		逢16进1
		其实是每四位二进制表示一位十六进制数
		包含0-9，a-f
		数字上以0x开头
- 十进制：
		18，99,1090

************************************************************
#浮点数
	
- 小数
- 计算机里面表示浮点数可以有条件省略
		3.1315
		3.
		0.5
		.5
- 科学计数法
		写法用 e或者E 后面跟整数表示10的指数
		176.23 == 1.7634e2
		0.876 == 8.76e-1

*************************************************************
#复数complex

- 定义和数学里一样
- 一个由实部和虚部构成的数字
- 虚部用 j或者J 表示
> - 5+3j
> - 3j
> - (3j)

*************************************************************
#布尔值

- 表示真假的值
- True和False  ==  1和0
- 布尔值可以和数字直接操作
	 >- age = 18 + True
	 >- age = 19

*************************************************************
#字符串

- 单引号、双引号、三单引号或者三双引号都可以表示字符串
- 单双引号交错使用：     '<a style="color:red"> hahaha </a>'
- 三引号：能够扩起多行信息
- 转义字符：  
    >- 借助反斜杠
    >- 换行：\n        制表：\t     
    >- 回车换行符： \r\n (Linux)
	- "Let's go" == 'Let\'s go'     
	-  \\\ = \\
	- "c:\user" --> "c:\\user"  

**************************************************************
#字符串格式化

- 利用百分号（%）
	- %d： 整数  
	- %s： 字符串
	- %f： 浮点数  
	> name = 'like'  
	
	> print('%s,你好' % name)  
	
	> s = "I am %s years old"  
	
    > print(s%('like',22))

- fromat函数格式化   （推荐使用此方法）
- "I am {}".format('like')

- "I am {0} and I am {1} years old".format('like',18)

- "I am {0} and I am {1} years old Yes,I am {0}".format('like',18)

***************************************************************
#None

- 表示什么都没有
- 如果函数没有返回值，可以返回 None
- 用来占位置
- 用来解除变量绑定

*****************************************************************
#表达式

- 由一个或者几个数字或者变量和运算符组合成的一行代码
- 通常会返回一个结果

*****************************************************************
#运算符

- 由一个以上的值经过变化得到的新值的过程就叫运算
- 用于运算的符号叫运算符
- 运算符分类：
	- 算数运算符  
		- 加减乘除：(+) (-) (*) (/)   	
		    >除号在py2和py3里结果不一致（py2里会四舍五入不保留小数点后的数）
		- 取余运算：(%) 
		    >除尽之后剩余的数
		- 地板除、取商运算：(//)
			>9 // 4 = 2
		- 幂运算、次方运算：(**)
			>9 ** 4 = 6561
	- 比较或者关系运算符
		- 比较结果是布尔值：True/False
			- 比较等于： == 
			    >b = a == 80
			      
			    >b = True或者False
			- 不等于： ！=
			- 大于，小于，大于等于，小于等于：
			    > \>  <  >==  <==
	- 赋值运算符
		- = ：赋值运算
		- +=： 是缩写
			>a += 7
			
			> a = a + 7
			
		- -=, *=, /=, //=, %=, **=, 都是缩写形式
	- 逻辑运算符
		- and 逻辑与
		- or  逻辑或
		- not 逻辑非
		    >python中逻辑运算没有异或运算
		- 运算规则：
			- and看做乘法，or看做加法
			- True看做1，False看做0
			- 则逻辑运算就能转换成整数数学运算
			- 最后结果如果为0则为False，否则为True
				> a = True
				
				> b = False
				
				> c = True
				
				> d = a and b or c  (d = a*b+c)
				
				> d = True
		- 逻辑运算的短路问题
			- 逻辑运算式，按照运算顺序计算，一旦能够确定整个式子未来的值，则不再进行计算，直接返回

		- 位运算
		= 成员运算
			- 检测一个变量是否是另一个变量的成员
			    > in
			
			    > not in 
		- 身份运算符
			- 用来检测两个变量是否是同一个变量
			- 区分与 ==
			- 语法： 
			    >is
			    
			    >is not

###运算符的优先级问题
- 括号最高优先级

*******************************************************************************
#程序结构

- 顺序
- 分支
	- if 条件表达式：   
			语句1
		
		elif：
			语句2
		
		else：
			语句3	
###条件表达式计算结果必须为布尔值
- if语句可以嵌套使用
	- python没有switch-case语句

- 循环
	- for循环
		>for 变量 in 序列：  
		----语句1
				···
	    
	    >for 变量 in 序列：  
            if 条件表达式：
					语句1
					···
				···
		·for···else···语句
			当for循环结束的时候，会执行else语句
			else是可选的

		·循环之break，contineu，pass
			break： 无条件结束整个循环
			contineu： 跳出当前循环，进行下一次循环
			pass： 通过这次循，不做任何事 

		·range：
			一般包含左边数字不包含右边数字
			randint是特例，他左右都包含
			range函数在py2和py3中有严重区别
		·while循环
			·当某条件成立的时候，就循环
			·for知道具体循环次数，while循环不知道，但知道具体成立条件
			·语法：
				>>>	while 条件表达式：
						pass
			·   >>> while 条件表达式：  #未进入循环，或者完成循环后进行else语句
						语句1
					else：
						语句2

*********************************************************************************
#函数

	·def  函数名(接收内容)：
		语句1
		···
		return 值或者函数
	参数：
		形式参数：
		 	在函数定义的时候用到的参数没有具体值，只是一个占位的符号，称为形参
		实际参数：
		 	在调用函数的时候输入的值
	返回值： 函数执行的结果
		return 关键字
		如果没有return，自动返回一个None
	参数详解：
		【参考资料】(https://www.cnblogs.com/bingabcd/p/6671368.html)
		 python参考资料：headfirst python --> 零基础入门学习python（小甲鱼）  --> 习题 -->   后期可以考虑腾讯公开免费课

	参数分类：
		·普通参数
			·定义的时候直接定义变量名
			·调用的时候直接把变量或者值放入指定位置
				>>> def 函数名（参数1，参数2，参数3·····）：

			#调用
				函数名（value1，value2····）
			#调用的时候，具体值参考的是位置，按位置赋值

		·默认参数
			·参数带有默认值
			·调用的时候，如果么米有相应形参赋值，默认使用默认值
				函数名（参数1，参数2，参数3 = 10，·····）：
			实例：
				>>> def reg(name,age,gender="male"):
						if gender == "male"
							print("{0} is {1}，and he is a good student")
						else:
							print("{0} is {1}, and she is a good student")
				>>> reg("mingyue",21)
				>>> reg("xiaojing",23,women)

		·关键字参数
			·语法

				def func(p1=v1,p2=v2......):
					func_body

				调用函数：

					func(p1=value1,p2=value2......)
			·比较麻烦，但是有好处：
				·不容易混淆
				·使用关键字参数，可以不考虑参数位置
			#普通参数，只按照位置传递，容易出错

				>>>def stu_key(name="No name", age=0, addr="No addr"):
						print("I am a student")
						print("我叫 {0}, 我今年{1}岁了, 我住{2}".format(name,age,addr))	

					n = "jingjing"
					a = 18
					addr = "我家"

					stu_key(age=a, name=n, addr=addr)

		·收集参数
			·把没有位置，不能和定义时的参数位置相对应的参数，放入一个特定放入数据结构中
			·语法
				def func(*args):
					func_body
					按照list使用方式访问args得到传入的参数

			·调用
				func9(p1,p2,p3, .....)

			·args不是必须这么写，但是强烈推荐使用args，约定俗成

		·收集参数之关键字收集参数
			·dict 字典
			·语法：

				def func( **kwargs):
					func_body

			·调用：

				 func(p1=v1, p2=v2, p3=v3, ......)

			·kwargs一般约定俗成
			·调用的时候，把多余的关键字参数放入kwargs
			·访问kwargs需要按照dict格式访问

			·访问kwargs：

				>>> def stu( **kwargs):
						pass
						for key,value in kwargs.items():
							print(key, "---", value)
************************************************************************
#list倒叙小思路：
	·切片法
	L = [1,2,3,4]
	print(L[-1::-1])
	>>> 4,3,2,1
同理，range函数倒叙也可以用负增长幅度！
************************************************************************
#系统内部 变量与数据的内部关系之 ID or 内存地址。
>>>
	a = 100
	c = a
	print(id(a), id(c))
	print(a, c)

	a = 101
	print(id(a), id(c))
	print(a, c)

	c = 101
	print(id(a), id(c))
	print(a, c)
>>>
	464828864 4464828864    # 将a赋值给c   两个变量ID相同
	100 100
	4464828896 4464828864    #  对a进行赋值  会改变a的ID
	101 100
	4464828896 4464828896   # 将c赋值101后   a和c  ID又相同 
	101 101					#注意此时并不是把c 指向了a 而是赋值与a一样的值
							#但a 和c ID相同！
	·结论：
	（这应该是python语言对内存占用这方面的一些优化，这样内存中重复数据
	  就不用存在两份，以节约内存占用，当要对其中一个变量做修改时，假如内存中有此数据，则直接
	  指向它，如果没有，则指向一个新创建的数据）
	（以此类推，在其他语言中，内存的使用应该也会遵循这一规则！）
	（有一丝c语言中指针的感觉！）
	注：不适用与list及其他数据类型
******************************************************************************
#list 切片操作及ID关系

	·对list切片操作会生成另一份list
	·即使使用L[:] 这样与源数据一样的操作

	当一个list直接赋值于另一个list时：
		list1 = list2
		两个list ID相同
	对 list2做修改时，list1依然指向list2
		· list1 依然等于 修改后的list2  （ID依然相同）
	#新发现：
		·list赋值会重新生成list
		·而做切片修改不会重新生成
		·但是[:]这种复制性修改会重新生成新的list
		#其实 只有list赋值操作才会生成新的数据
			而修改list不会
*******************************************************************************
#list  del（删除）操作

	·直接原地移除del的目标
	修改后ID相同
*******************************************************************************
#列表相加

	a = [1, 2, 3, 4, 5]
	b = [5, 6, 7, 8, 9]
	c = a + b
	c = [1, 2, 3, 4, 5, 5, 6, 7, 8, 9]

#列表相乘

	#列表直接和一个整数相乘
	a = [1,2,3,4,5]
	b = a*10
	#相当于把n个列表接在一起

#成员资格运算

	·判断一个元素是否在list里面
	·if a in b:
############################################################################
#双层列表变异：

	a = [['one', 1], ['two', 2], ['three', 3], ['a', 't', 3, 5]]
	for i,y,*args in a:
    	print(i,y,*args)


#列表生成式

	·a = [i for i in range(1,10)]

	·双层for嵌套
	·a = [[i]+[n] for i in range(1,4) for n in range(1,400) if n%100 == 0]

#列表长用函数：
	·len(可迭代) ： 求列表长度（也可以字符串，元祖，字典等）
	·max(可迭代) ： 求最大值
	·min(可迭代) ： 求最小值
	·a.append( date ): 在末尾追加
	·a.insert(index, date): 指定位置插入（插入位置是index前面）（不常用）
	·del a[index] : 删除（不常用）（按下标来）
	·a.pop()  :从对位拿出一个元素，即把最后一个元素取出来
		a = [1, 2, 3, 4, 5]
		last_ele = a.pop()
		print( last_ele )
		print( a )

		100
		[1,2,3,4]

	·a.remove( value ) ： 在列表中删除指定的值得元素（按值来删除)
	·a.clear() : 原list清空！
		·有助于内存回收！
	·a.reverse() : 原list翻转
	·a.extend() : 扩展列表，两个列表，把一个直接拼接到后一个上
	·a.count() : 查找列表中指定值 或元素个数
	·a.copy ： 拷贝，浅拷贝
#浅拷贝和深拷贝：
	·a = [1, 2, 3, [10, 20, 30]]
	·内层的list 在浅拷贝时 ： 拷贝过去的是地址！ 也就是 依旧指向原数据


#传值和传址

	·简答数值：传值
	·list及其他：传址

#元祖函数：

	·a.index() ： 求指定元素在元祖中的索引位置
	·与list函数基本通用

#集合-set

	·一堆确定的无序的唯一数据，集合中每一个数据成为一个元素
	s = {1,2,3,4,5}  大括号内一定要有值，不然被定义为dict
	s = set()
	·集合内数据无序，即无法使用索引和分片
	·集合内部数据元素具有唯一性，可以用来排除重复数据
	·集合内的数据， str, int, float, tuple, 冰冻集合等，即内部职能防止可哈希数据

#集合序列操作

	·成员检测：
		for date in set():

	·集合遍历操作
		for
#集合的内涵（集合生成式）
	·集合会自动过滤掉重复元素
	s = {23,12,34,12,21,1,3,4,2,2}

	·普通集合内涵（集合生成式）
	ss = {i for i in s}

	·带条件的集合生成式
	sss = {i for i in s if i % 2 == 0}
	
	·多循环的集合生成式
	s1 = {1, 2, 3, 4}
	s2 = {"i", "love", "me"} 

	s = {m*n for m in s1 for n in s2}
	（生成后！无序！无序！无序！）

#集合的函数，关于集合的函数

	len，max， min ：和其他基本函数一直

	set() ：生成一个集合

	#新函数

	add ： 向集合内添加元素

	clear() ：原地清空集合

	copy ：浅拷贝

	remove ：移除指定的值  （直接改变原有值，如果要删除的值不存在，报错）

	discard ：移除集合中指定得的值 （跟remove医院，但是如果要删除的值不存在，不报错）

	pop ： ”随机“移除一个元素

	交叉并补 ：

		intersection: 交集
		difference: 差集
		union: 并集
		issubset: 检查一个集合是否为另一个子集
		issuperset: 检查一个集合是否为另一个超集

		s1 = {1,2,3,4,5,6}
		s2 = {5,6,7,8,9}

		s_1 = s1.intersection(s2)
		s_1 = {5, 6}

		s_2 = s1.difference(s2)
		s_2 = {1, 2, 3, 4}

		s_3 = s1.issubset(s2)
		s3 = False

#集合的数学操作

	s1 = {1,2,3,4,5,6}
	s2 = {5,6,7,8,9}

	s_1 = s1 - s2
	{1, 2, 3, 4}

#冰冻集合

	·冰冻集合就是不可以进行任何修改的集合
	forzenset():

	·forzenset是一种特殊的集合， 出了不能修改，具有集合一切特性

#字典 dict

	·字典是一种组合数据，没有顺序的组合数据，数据以键值对形式出现
	·可以用 dice() 创建

		d = dict("one":1, "two":2, "three":3)

		d = dict(one=1, two=2, three=3)

		d = dict(['one',1], ('two', 2), ('three', 3))


#字典的特征

	·没有分片，没有索引
	·每个数据都是kv对，key value
		key：必须是可哈希的值，比如int， string， float， tuple 但是 list set dict不行
		value： 任何值

#字典常见操作

	print (d["key"])
	
	d["key"] = 2

	删除：
	del d["key"]

	成员检测：
	检测的是key内容

	遍历：
	·for key in d:
		key d[key]

	·for key in d.keys():
		key d[key]

	·for v in d.values():
		value

	·for k,v in d.items():
		key value


#字典生产式

	d = {"one":1, "two":2, "three":3}
	dd = {k:v for k,v in d.items()}

	ddd = {k:v for k,v in d.items() if v % 2 == 0}

#字典相关函数

	len max min dict
	str(字典)： 返回字典的字符串格式

	clear: 原地清空

	items：返回字典的键值对组成的元祖格式

	keys：返回字典的键组成的一个结构

	values： 返回字典的值组成的一个结构

	#get：根据指定键返回相应的值， 好处是可以设置默认值 （不会报错，没有时返回None）

		a = d.get('one', 100)   没有'one'时  按默认值100输出

	fromkeys： 使用指定的序列作为键， 使用一个值作为字典的所有键的值

		l = ['eins', 'zwei', 'dree']

		d = dict.fromkeys(l, 'hahaha)

		·fromkeys 的两个参数   以及调用。
	
#面向对象（OOP）
- python面向对象
- 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合，Mixin
- 魔法函数
    - 魔法函数概述
    - 构造类魔法函数
    - 运算类魔法函数
    
# 1 面向对象概述（ObjectOriented，OO）
- OOP思想
    - 接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的
- 几个名词
    - OO：面向对象
    - OOA:面相对的分析
    - OOD：面向对象的设计
    - OOI：面向XXX的实现
    - OOP：面向XXX的编程
    - OOA -> OOD -> OOI ：面向对象的实现过程
- 类和对象的概念
    - 类：抽象名词，代表一个集合，共性的食物
    - 对象：具象的事物，单个个体
    - 类和对象的关系
        - 一个具象，代表一类事物的某一个个体
        - 一个是抽象，代表的是一大类事物
- 类中的内容，应该具有两个内容
    - 表明事物的特征，叫做属性(变量)
    - 表明事物功能或动作，称为成员方法（函数）
    
# 2. 类的基本实现
- 类的命名
    - 遵守变量命名的规范
    - 大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词和单词直接相接）
    - 尽量避开和系统命名相似的命名
- 如何声明一个类
    - 比如用 calss 关键字
    - 类由属性和方法构成，其他不允许出现
    - 成员属性定义可以直接使用变量赋值，如果没有值，允许使用None
    - 案例 01.py 
- 实例化类

        变量 = 类名() # 实例化了一个对象
- 访问对象成员
    - 使用.操作符
    
            obj.成员属性名词
            obj.成员方法
- 可以通过默认内置变量检查类和对象的所有成员
    - 对象所有成员检查
    
            obj.__dict__  #dict前后各有两个下划线
    - 类所有的成员
    
            class_name.__dict__  # dict前后各有两个下划线        
    
    
# 3. anaconda基本使用
- anaconda主要是一个虚拟环境管理器
- 还是一个安装管理包
- conda list ： 显示anaconda安装的包
- conda env list ： 显示anaconda的虚拟环境
- conda create -n xxx python=3.6：创建名叫xxx的python为3.6版本的虚拟环境

# 4. 类的对象的成员分析
- 类和对象都可以存储成员，成员可以归类所有，也可以归对象
- 类存储成员式使用的是与类关联的一个对象
- 对象存储成员是存储在当前对象中
- 对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员，
如果对象当中有此成员，一定使用对象中的成员
- 创建对象的时候，类中的成员不会放入到对象中，而是得到一个空对象，没有成员
- 对对象不存在的成员赋值时，自动添加到该对象的实例里

# 5. 关于self
- self在对象的方法中表示当前对象本身，如果通过对象调用
一个方法，那么该对象会自动转入到当前方法的第一个参数中
- self并不是关键字，只是一个用于接受对象的普通参数，理论
上可以用任何一个普通变量代替
- 方法中有self形参的方法称为非绑定类的方法，
可以通过对象访问，没有self的是绑定类的方法，只能通过类访问
- 使用类访问绑定类的方法时， 如果类方法中需要访问当前类
的成员， 可以通过__class__ 
# isinstance()
- 对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，
可以使用isinstance()函数
- 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。
    >- isinstance([1, 2, 3], (list, tuple))
    >- True
    >- isinstance((1, 2, 3), (list, tuple))
    >- True

#鸭子模型
- 不关心你到底是不是鸭子（同一类型）
- 只要具有相应的参数，就可以视为鸭子(可使用类型)  
        
        class A():
            def say(self):
                print("Hi")
                print("{0}, {1}".format(self.name, self.age)
            
        class B():
            name = "apple"
            age = 18
          
        A.say(B)   
        
# 6. 面对对象的三大特性
- 封装
- 继承
- 多态

##6.1 封装
- 对对象的成员进行访问限制
- 封装的三个级别：
    - 公开，public
    - 受保护的， protected
    - 私有的， private
    - public， private， protected不是关键字
- 判别对象的位置
    - 对象内部
    - 对象外部
    - 子类中
- 私有
    - 私有成员是最高级别的封装，只能在当前类或对象中访问
    - 在成员前面添加两个下划线
    
            class Person():
                #name是共有成员
                name = "liuying"
                
                #__age就是私有成员
                __age = 18
                **！！（_Person__age）一样能访问私有成员**
                
        - python的私有成员可以通过：
            - _Person__age  可以访问
    - self（即调用方法时，第一个self不需要传入，自动传入）
    - 如果外部要获取name和score，且不让外部修改应该：
        - 给类增加 get_name 和 get_score 的方法
        
                class Student(objcet):
                    ```
                    
                    def get_name(self):
                        return self.__name
                        
                    def get_score(self):
                        return self.__score
                    
    - 如果有要允许外部代码修改 name和score 应该：
        - 给类增加set_score 的方法
        
                class Student(object):
                    ```
                    
                    def set_score(self, score):
                        self.__score = score
                        
        - 这样做的好处是可以对参数做检查，避免传入无效参数
        
                class Student(object):
                    ```
                    
                    def set_score(self, score):
                        if 0 <= score <= 100:
                            self.score = score
                        else:
                            raise ValueError("bad score")
                            
                          
- __xxx\__ 是 特殊变量 ， 不能用来当做变量名，特殊变量可以直接访问
不是private变量（私有变量）。
- 一个下划线开头的 _xxx ，约定俗成将其视为私有变量，不要随便访问
- 受保护的封装
    - 受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，
    但是在外部不可以访问
    - 封装方法： 在成员名称前添加一个下划线即可
    

- 总结：python没有真正限制你访问私有变量，一切看自觉

#继承和多态          
- 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。

- 比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：

        class Animal(object):
            def run(self):
            print('Animal is running...')
            
- 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：

        class Dog(Animal):
            pass

        class Cat(Animal):
            pass
            
- 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。
- 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：
        
        dog = Dog()
        dog.run()

        cat = Cat()
        cat.run()
        
- 运行结果如下：

        Animal is running...
        Animal is running...
        
- 作用： 减少代码，增加代码的复用性
- ###子类一旦继承父类，则可以使用父类中除私有成员外的所有内容
    - 可访问 受保护的、公开的
    
    - 子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用
    - 子类中可以定义独有的成员属性和方法
    - 子类中定义的成员和父类成员如果相同，则优先使用子类中的成员
    - 子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员进行代码重用，
    可以使用  父类名.父类成员  的格式来调用父类成员，也可以使用super().父类成员
    